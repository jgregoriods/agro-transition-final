res
res <- optim(c(A, x0, X, M), fn, method="CG")
res
res <- optim(c(A, x0, X, M), fn, method="L-BFGS-B")
res
res <- optim(c(A, x0, X, M), fn, method="SANN")
res
res <- optim(c(A, x0, X, M), fn, method="Brent")
source("mod.R")
res
res <- optim(res$par, fn)
res
M
m
m <- m[(nrow(m)-1),]
m
m <- read.csv("mod.csv")
m <- m[1:(nrow(m)-1),]
m
A <- (max(m$d18O) - min(m$d18O))/2
x0 <- m[which.max(m$d18O),]$erj_dist
M <- (max(m$d18O) + min(m$d18O))/2
X <- max(m$erj_dist) - min(m$erj_dist)
res <- optim(c(A, x0, X, M), fn)
res
source("mod.R")
res
library(pastclim)
climate_20k <- region_slice(
time_bp = -20000,
bio_variables = c("bio01", "bio10", "bio12"),
dataset = "Example"
)
plot(climate_20k)
climate_3k <- region_slice(
time_bp = -3000,
bio_variables = c("biome"),
dataset = "Example"
)
climate_3k <- region_slice(
time_bp = -3000,
bio_variables = c("biomes"),
dataset = "Beyer2020"
)
climate_3k <- region_slice(
time_bp = -3000,
bio_variables = c("biome"),
dataset = "Beyer2020"
)
plot(climate_3k)
climate_2k <- region_slice(
time_bp = -2000,
bio_variables = c("biome"),
dataset = "Beyer2020"
)
climate_1k <- region_slice(
time_bp = -1000,
bio_variables = c("biome"),
dataset = "Beyer2020"
)
s <- stack(climate_3k, climate_2k, climate_1k)
s <- c(climate_3k, climate_2k, climate_1k)
plot(s)
cr <- crop(s, c(-60,-50,-35,-25))
plot(cr)
cr <- crop(s, c(-60,-45,-35,-25))
plot(cr)
cr <- crop(s, c(-60,-45,-35,-20))
plot(cr)
get_biome_classes(Beyer2020)
get_biome_classes("Beyer2020")
get_biome_classes("Krapp2021")
download_dataset("Krapp2021")
get_biome_classes("Beyer2020")
climate_3k <- region_slice(
time_bp = -3000,
bio_variables = c("biome"),
dataset = "Krapp2021"
)
climate_2k <- region_slice(
time_bp = -2000,
bio_variables = c("biome"),
dataset = "Krapp2021"
)
climate_1k <- region_slice(
time_bp = -1000,
bio_variables = c("biome"),
dataset = "Krapp2021"
)
s <- c(climate_3k, climate_2k, climate_1k)
cr <- crop(s, c(-60,-45,-35,-20))
plot(cr)
library(p3k14c)
# install.packages("remotes")
remotes::install_github("people3k/p3k14c@2022.06")
library(p3k14c)
p3k14c::p3k14c_data
head(p3k14c::p3k14c_data)
names(p3k14c::p3k14c_data)
library(p3k14c)
data
p3k14c_data
write.csv(p3k14c_data, "p3k14c.csv")
library(pastclim)
download_dataset(dataset = "Krapp2021")
get_downloaded_datasets()
help("Beyer2020")
help("Krapp2021")
help("Barreto2023")
get_vars_for_dataset(dataset = "Barreto2023")
r <- raster(region_slice(-11000, bio_variables = "bio01", dataset="Barreto2023"))
r <- rast(region_slice(-11000, bio_variables = "bio01", dataset="Barreto2023"))
download_dataset(dataset = "Barreto2023")
r <- rast(region_slice(-11000, bio_variables = "bio01", dataset="Barreto2023"))
plot(r)
r <- rast(region_slice(-11000, bio_variables = "bio01", dataset="Krapp2021"))
plot(r)
# Install and load spatstat package
install.packages("spatstat")
library(spatstat)
# Load example dataset
data(cells)
# Fit a point process model (homogeneous Poisson process)
fit <- ppm(cells, ~1)
# Generate an envelope around the K-function
envel <- envelope(cells, Kest, nsim=39, rank=1)
# Plot the envelope
plot(envel)
envel$lo
Kest(cells)
obs_k <- Kest(cells)
obs_k
cells
update.packages(ask = FALSE, checkBuilt = TRUE)
library(terra)
library(terra)
f <- list.files("sel_rasters", full.names=T, pattern=".tif$")
dem <- rast("sel_rasters/cropped_dem.tif")
for (file in f) { x <- rast(file); x <- project(x, dem); writeRaster(x, paste0("proj_rasters/", names(x), ".tif")); rm(x); gc() }
f
basename(f)
for (file in f) { x <- rast(file); x <- project(x, dem); writeRaster(x, paste0("proj_rasters/", basename(file))); rm(x); gc() }
f <- list.files("proj_rasters", full.names=T)
f
r <- rast(f)
plot(r)
names(r)
unique(names(r))
plot(r[[6]])
plot(r[[21]])
names(r[[21]]) <- "twi"
plot(r[[21]])
r[[21]]
writeRaster(r[[21]], "proj_rasters/twi.tif")
f <- list.files("proj_rasters", full.names=T)
r <- rast(f)
plot(r)
names(r)
a <- read.csv("pts.csv")
a
head(a)
head(a, header=NULL)
read.csv("pts.csv", header=NULL)
a <- read.csv("pts.csv")
a
head(a)
library(sf)
pts <- st_as_sf(a)
pts <- st_as_sf(a, coords = c("x", "y"))
pts
plot(pts)
library(gstat)
vgm <- variogram(z~1, pts)
plot(vgm)
fit <- fit.variogram(vgm, vgm(6, c("Exp", "Sph", "Gau"), 50, 0))
plot(vgm, fit)
site_bound <- vect("data/shp/site_bound.shp")
library(terra)
site_bound <- vect("~/projects/caldeirao/data/shp/site_bound.shp")
# grid for interpolation
xrange <- seq(ext(site_bound)[1], ext(site_bound)[2], 1)
yrange <- seq(ext(site_bound)[3], ext(site_bound)[4], 1)
zrange <- seq(10,90,20)
site_grid <- expand.grid(xrange, yrange, zrange)
colnames(site_grid) <- c("x", "y", "z")
site_grid <- st_as_sf(site_grid, coords=c("x", "y", "z"), crs=st_crs(site_bound))
plot(site_grid)
site_bound <- vect("~/projects/caldeirao/data/shp/site_bound.shp")
# grid for interpolation
xrange <- seq(ext(site_bound)[1], ext(site_bound)[2], 1)
yrange <- seq(ext(site_bound)[3], ext(site_bound)[4], 1)
site_grid <- expand.grid(xrange, yrange)
colnames(site_grid) <- c("x", "y")
site_grid <- st_as_sf(site_grid, coords=c("x", "y"), crs=st_crs(site_bound))
plot(site_grid)
krig <- krige(z~1, pts, site_grid, fit)
st_crs(pts)
st_crs(pts) <- st_crs(site_grid)
krig <- krige(z~1, pts, site_grid, fit)
krig
plot(krig)
r <- rast(krig$var1.pred)
krig$var1.pred
r <- rast(site_grid)
r
plot(r)
values(r) <- krig$var1.pred
raster_template <- rast(ext(krig), res=1)
r <- rasterize(krig, raster_template, "var1.pred")
plot(r)
m <- mask(r, site_bound)
st_crs(r)
st_crs(r) <- st_crs(site_bound)
crs(r) <- st_crs(site_bound)
crs(r) <- crs(site_bound)
m <- mask(r, site_bound)
plot(m)
writeRaster(m, "caldeiao_topo.tif")
df <- as.data.frame(m, xy = TRUE)
names(df) <- c("x", "y", "z")
model <- lm(z ~ poly(x, 2) + poly(y, 2), data = df)
df$trend <- predict(model, newdata = df)
df$detrended <- df$z - df$trend
detrended_raster <- m
values(detrended_raster) <- df$detrended
plot(detrended_raster)
df <- as.data.frame(r, xy = TRUE)
names(df) <- c("x", "y", "z")
model <- lm(z ~ poly(x, 2) + poly(y, 2), data = df)
df$trend <- predict(model, newdata = df)
df$detrended <- df$z - df$trend
detrended_raster <- r
values(detrended_raster) <- df$detrended
plot(detrended_raster)
setwd("projects/agro-transition-final/")
library(ape)
library(caret)
library(dplyr)
library(fastshap)
library(fields)
library(ggplot2)
library(gridExtra)
library(latticeExtra)
library(progress)
library(randomForestSRC)
library(rasterVis)
library(RColorBrewer)
library(rnaturalearth)
library(rnaturalearthdata)
library(sf)
library(sp)
library(shapviz)
library(terra)
library(tidyterra)
library(vegan)
library(ggpubr)
# please download the quickMEM source code from
# https://github.com/ajsmit/Quantitative_Ecology/blob/main/Num_Ecol_R_book_ed1/quickMEM.R
source("quickMEM.R")
# dependencies for quickMEM
library(ade4)
sf_use_s2(FALSE)
source("var_names.R")
# Define datum
WGS84 <- '+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs'
# Mask the NA cells for plotting
bio <- rast("rasters/bioclim/bio01.asc")
alt <- rast("rasters/terrain/altitude.asc")
land_mask <- (!is.na(bio) & !is.na(alt))
# For the figures
coast <- st_union(ne_countries())
# Read data
raw_data <- read.csv("data/c14dates.csv")
all_data_points <- st_as_sf(raw_data, coords=c("Longitude", "Latitude"), crs=WGS84)
all_data_points <- all_data_points[order(all_data_points$AgeCalBP), ]
# Ages
age_plot <- ggplot() +
geom_sf(data=coast, fill="white") +
geom_sf(data=all_data_points, aes(col=AgeCalBP), pch=16, size=0.8, alpha=0.6) +
scale_color_viridis_c(option="turbo", name="Age (cal BP)") +
scale_x_continuous(expand = c(0,0)) +
scale_y_continuous(expand = c(0,0))
png("figs/C14Ages.png", width=2000, height=1000, res=300)
plot(age_plot)
dev.off()
# Sources
all_data_points$Database[all_data_points$Database == ""] <- "Other source"
n <- length(unique(all_data_points$Database))
source_plot <- ggplot() +
geom_sf(data=coast, fill="white") +
geom_sf(data=all_data_points, aes(col=Database)) +
scale_color_manual(values = colorRampPalette(brewer.pal(8, "Set3"))(n)) +
scale_x_continuous(expand = c(0,0)) +
scale_y_continuous(expand = c(0,0))
png("figs/C14Sources.png", width=2000, height=1000, res=300)
plot(source_plot)
dev.off()
# Read all environmental rasters
# we read them separately for varpart
bioclim_files <- list.files("rasters/bioclim", full.names=T)
soil_files <- list.files("rasters/edaphic", full.names=T)
terrain_files <- list.files("rasters/terrain", full.names=T)
layers <- c(rast(bioclim_files), rast(soil_files), rast(terrain_files))
# Fill NAs within a radius of 3 cells to avoid loosing data
# especially on coastal regions.
layers <- focal(layers, w=matrix(1,3,3), fun=mean, na.policy="only")
# Create layers with latitude and longitude to be added as predictors
rlon <- rlat <- rast(layers[[1]])
xy <- xyFromCell(layers[[1]], 1:ncell(layers[[1]]))
values(rlon) <- xy[,1]
values(rlat) <- xy[,2]
names(rlon) <- "xcoord"
names(rlat) <- "ycoord"
layers <- c(layers, rlon, rlat)
# Extract environmental data for each point and create a data frame
data <- terra::extract(layers, raw_data[c("Longitude", "Latitude")], ID=FALSE)
# Target variable is time since first transition
data$y <- max(raw_data$AgeCalBP) - raw_data$AgeCalBP
data <- na.omit(data)
# Store latitude and longitude for use later
xcoord <- data$xcoord
ycoord <- data$ycoord
# Predictors and target
X <- data[,1:(ncol(data)-3)]
y <- data$y
# Remove collinearity
cor_vars <- findCorrelation(cor(X), names=T)
X <- X[,!colnames(X) %in% cor_vars]
findLinearCombos(X) # none
layers <- subset(layers, cor_vars, negate=T)
data <- data[,!colnames(data) %in% cor_vars]
write.csv(data, "saved_data/data.csv", row.names=FALSE)
# Variation partitioning
terrain <- X[,paste(colnames(X), ".asc", sep="") %in% basename(terrain_files)]
bioclim <- X[,paste(colnames(X), ".asc", sep="") %in% basename(bioclim_files)]
soil <- X[,paste(colnames(X), ".asc", sep="") %in% basename(soil_files)]
spatial <- data[,c("xcoord", "ycoord")]
v <- varpart(y, terrain, bioclim, soil, spatial)
plot(v, Xnames=c("Terrain", "Bioclim", "Soil", "Spatial"), bg=1:4)
findLinearCombos(X)
layers
data$event <- 1
names(layers)
median_survival <- function(row) {
idx <- which(row < 0.5)
if (length(idx) > 0) {
return(rf_model$time.interest[idx[1]])
} else {
return(NA)
}
}
set.seed(100)
print("Tuning random forest...")
o <- tune(Surv(y, event) ~ ., data=data, sampsize=nrow(data) * 0.8)
o
print("Fitting random forest...")
rf_model <- rfsrc(Surv(y, event) ~ ., data=data, importance=TRUE,
nodesize=o$optimal[1], mtry=o$optimal[2], save.memory = TRUE,
sampsize=nrow(data) * 0.8)
print(rf_model)
plot(rf_model)
predicted <- apply(rf_model$survival, 1, median_survival)
residuals <- y - predicted
data_points <- st_as_sf(data, coords=c("xcoord", "ycoord"), crs=WGS84)
data_points["pred"] <- max(raw_data$AgeCalBP) - predicted
data_points["res"] <- residuals
data_points <- data_points[order(abs(data_points$res)), ]
pred_plot <- ggplot() +
geom_sf(data=coast, fill="white") +
geom_sf(data=data_points, aes(col=pred)) +
scale_color_viridis_c(option="turbo", name="Predicted yr BP") +
scale_x_continuous(expand = c(0,0)) +
scale_y_continuous(expand = c(0,0)) +
coord_sf(ylim = c(-60, 90))
png("figs/SI_pred.png", width=2000, height=1000, res=300)
plot(pred_plot)
dev.off()
plot(pred_plot)
res_plot <- ggplot() +
geom_sf(data=coast, fill="white") +
geom_sf(data=data_points, aes(col=res)) +
scale_color_viridis_c(name="Residual", option="plasma") +
scale_x_continuous(expand = c(0,0)) +
scale_y_continuous(expand = c(0,0)) +
coord_sf(ylim = c(-60, 90))
png("figs/SI_res.png", width=2000, height=1000, res=300)
plot(res_plot)
dev.off()
plot(res_plot)
# Convert raster stack to data frame for prediction
df <- as.data.frame(layers)
df[is.na(df)] <- 0
print("Predicting random forest...")
raw_rf_pred <- predict(rf_model, df, na.action="na.omit")
times <- c(4000, 6000, 8000, 10000)
indices <- lapply(times, function(t) {
which.min(abs(rf_model$time.interest - t))
})
rf_stack <- NULL
for (i in indices) {
# 1 - probability of "survival" = probability that the event happened
time_slice <- rast(layers[[1]])
values(time_slice) <- 1 - raw_rf_pred$survival[,i]
if (is.null(rf_stack)) {
rf_stack <- time_slice
} else {
rf_stack <- c(rf_stack, time_slice)
}
}
names(rf_stack) <- c("8k", "6k", "4k", "2k")
# Mask by land
rf_stack[land_mask == 0] <- NA
predicted_time <- apply(raw_rf_pred$survival, 1, median_survival)
predicted_time_r <- layers[[1]]
values(predicted_time_r) <- max(raw_data$AgeCalBP) - predicted_time
predicted_time_r[land_mask == 0] <- NA
rm(raw_rf_pred)
gc()
save(rf_model, file="saved_data/rf_model.RData")
# load("saved_data/rf_model.RData")
writeRaster(rf_stack, "saved_data/rf_stack.tif", overwrite=TRUE)
# rf_stack <- rast("saved_data/rf_stack.tif")
writeRaster(predicted_time_r, "saved_data/predicted_time_r.tif", overwrite=TRUE)
# Random forest plots
rf_plot <- ggplot() +
geom_sf(data=coast, fill="white") +
geom_spatraster(data=rf_stack) +
facet_wrap(~lyr) +
geom_sf(data=coast, fill="transparent") +
scale_fill_viridis_c(option="turbo", na.value="transparent", name="Probability") +
scale_x_continuous(expand = c(0,0)) +
scale_y_continuous(expand = c(0,0)) +
coord_sf(ylim = c(-60, 90))
png("figs/RForest.png", width=2000, height=1000, res=300)
plot(rf_plot)
dev.off()
plot(rf_plot)
# Predicted time
rf_pred <- ggplot() +
geom_sf(data=coast, fill="white") +
geom_spatraster(data=predicted_time_r) +
geom_sf(data=coast, fill="transparent") +
scale_fill_viridis_c(option="turbo", na.value="transparent", name="Predicted yr BP") +
scale_x_continuous(expand = c(0,0)) +
scale_y_continuous(expand = c(0,0)) +
coord_sf(ylim = c(-60, 90))
png("figs/RForestPred.png", width=2000, height=1000, res=300)
plot(rf_pred)
dev.off()
plot(rf_pred)
pfun <- function(object, newdata) {
predict(object, newdata)$predicted
}
xvars <- select(data, -c(y, event))
print("Calculating Shapley values")
print("This may take a while...")
system.time({explainer <- explain(rf_model, X=xvars, pred_wrapper=pfun, nsim=2, adjust=TRUE)})
colnames(xvars) <- var_names(colnames(xvars))
source("var_names.R")
colnames(xvars) <- var_names(colnames(xvars))
colnames(xvars) <- var_names[colnames(xvars)]
colnames(explainer) <- colnames(xvars)
shv <- shapviz(explainer, X=xvars)
sv_importance(shv, max_display=10, kind="beeswarm", size=0.6, alpha=0.6, pch=16) +
scale_color_gradient(low="blue", high="red")
top_vars <- names(sort(apply(abs(explainer), 2, mean), decreasing=T))
top_vars <- top_vars[top_vars != "Longitude" & top_vars != "Latitude"]
shap_scores_df <- as.data.frame(explainer)
shap_scores_df$xcoord <- data$xcoord
shap_scores_df$ycoord <- data$ycoord
shap_points <- st_as_sf(shap_scores_df, coords=c("xcoord", "ycoord"), crs=WGS84)
shap_maps <- lapply(1:4, function(i) {
shap_points_ordered <- shap_points %>% arrange(get(top_vars[i]))
ggplot() +
geom_sf(data=coast, fill="white") +
geom_sf(data=shap_points_ordered, aes(color=get(top_vars[i])), size=0.6, alpha=0.6, pch=16) +
scale_color_viridis_c(option="turbo", name="Shapley value") +
scale_x_continuous(expand = c(0,0)) +
scale_y_continuous(expand = c(0,0)) +
coord_sf(ylim = c(-60, 90)) +
labs(title=top_vars[i]) +
theme(
plot.title = element_text(
size = 10,
hjust = 0.5
),
legend.title = element_text(size=8)
)
})
ggarrange(plotlist=shap_maps, common.legend=TRUE, legend="right")
dependence_plots <- lapply(1:4, function(i) {
sv_dependence(shv, v=top_vars[i], size=0.6, alpha=0.6, pch=16) +
scale_color_gradient(low="blue", high="red") +
# change y labels to "Shapley value"
labs(y="Shapley value")
})
ggarrange(plotlist=dependence_plots, common.legend=TRUE, legend="right")
sv_importance(shv, max_display=10, kind="beeswarm", size=0.6, alpha=0.6, pch=16) +
scale_color_gradient(low="blue", high="red")
names(rf_model$importance) <- var_names[colnames(rf_model$importance)]
plot(rf_model)
names(rf_model$importance) <- var_names[names(rf_model$importance)]
plot(rf_model)
set.seed(100)
print("Tuning random forest...")
o <- tune(Surv(y, event) ~ ., data=data, sampsize=nrow(data) * 0.8)
print("Fitting random forest...")
rf_model <- rfsrc(Surv(y, event) ~ ., data=data, importance=TRUE,
nodesize=o$optimal[1], mtry=o$optimal[2], save.memory = TRUE,
sampsize=nrow(data) * 0.8)
names(rf_model$importance) <- var_names[names(rf_model$importance)]
plot(rf_model)
