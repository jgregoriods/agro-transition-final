makeNumericParam("M", lower = -7, upper = -3)
)
)
r <- randomsearch(obj.fun)
r
obj.fun <- makeSingleObjectiveFunction(
fn = function(x) {
return (least_squares(m$d18O, foo(m$erj_dist, x[1], x[2], x[3], x[4])))
},
par.set = makeParamSet(
makeNumericParam("A", lower = 0.9, upper = 1.1),
makeNumericParam("x0", lower = 1, upper = 4),
makeNumericParam("X", lower = 20, upper = 26),
makeNumericParam("M", lower = -7, upper = -3)
)
)
r <- randomsearch(obj.fun)
r
r <- randomsearch(obj.fun, max.evals = 100)
r
r <- randomsearch(obj.fun, max.evals = 1000)
r
res <- randomSearch(obj.fun, max.eval = 1000)
res <- randomsearch(obj.fun, max.eval = 1000)
yhat <- foo(m$erj_dist, res$xbest[1], res$xbest[2], res$xbest[3], res$xbest[4])
yhat
res$par.set
res
res$minimize
res$add.transformed.x
res$env
summary(res)
summary(res)$x
str(res)
summary(res)[1]
summary(res)[2]
summary(res)$best.x
summary(res)$best.x$A
yhat <- foo(m$erj_dist, summary(res)$best.x$A, summary(res)$best.x$x0, summary(res)$best.x$X, summary(res)$best.x$M)
yhat
plot(m$erj_dist, m$d18O)
lines(m$erj_dist, yhat)
res <- randomsearch(obj.fun, max.eval = 10000)
res
yhat <- foo(m$erj_dist, summary(res)$best.x$A, summary(res)$best.x$x0, summary(res)$best.x$X, summary(res)$best.x$M)
plot(m$erj_dist, m$d18O)
lines(m$erj_dist, yhat)
optim
optim()
least_squares <- function(y, y_hat) {
return (sum((y - y_hat)^2))
}
fn <- function(x) {
A <- x[1]
x0 <- x[2]
X <- x[3]
M <- x[4]
return (least_squares(m$d18O, foo(m$erj_dist, A, x0, X, M)))
}
m <- read.csv("mod.csv")
A <- (max(m$d18O) - min(m$d18O))/2
x0 <- m[which.max(m$d18O),]$erj_dist
M <- (max(m$d18O) + min(m$d18O))/2
X <- max(m$erj_dist) - min(m$erj_dist)
A
res <- optim(c(A, x0, X, M), fn)
foo <- function(x, A, x0, X, M) {
return ((A * cos(2*pi*((x-x0)/X))) + M)
}
res <- optim(c(A, x0, X, M), fn)
res
res <- optim(c(A, x0, X, M), fn, method="BFGS")
res
res <- optim(c(A, x0, X, M), fn, method="CG")
res
res <- optim(c(A, x0, X, M), fn, method="L-BFGS-B")
res
res <- optim(c(A, x0, X, M), fn, method="SANN")
res
res <- optim(c(A, x0, X, M), fn, method="Brent")
source("mod.R")
res
res <- optim(res$par, fn)
res
M
m
m <- m[(nrow(m)-1),]
m
m <- read.csv("mod.csv")
m <- m[1:(nrow(m)-1),]
m
A <- (max(m$d18O) - min(m$d18O))/2
x0 <- m[which.max(m$d18O),]$erj_dist
M <- (max(m$d18O) + min(m$d18O))/2
X <- max(m$erj_dist) - min(m$erj_dist)
res <- optim(c(A, x0, X, M), fn)
res
source("mod.R")
res
library(pastclim)
climate_20k <- region_slice(
time_bp = -20000,
bio_variables = c("bio01", "bio10", "bio12"),
dataset = "Example"
)
plot(climate_20k)
climate_3k <- region_slice(
time_bp = -3000,
bio_variables = c("biome"),
dataset = "Example"
)
climate_3k <- region_slice(
time_bp = -3000,
bio_variables = c("biomes"),
dataset = "Beyer2020"
)
climate_3k <- region_slice(
time_bp = -3000,
bio_variables = c("biome"),
dataset = "Beyer2020"
)
plot(climate_3k)
climate_2k <- region_slice(
time_bp = -2000,
bio_variables = c("biome"),
dataset = "Beyer2020"
)
climate_1k <- region_slice(
time_bp = -1000,
bio_variables = c("biome"),
dataset = "Beyer2020"
)
s <- stack(climate_3k, climate_2k, climate_1k)
s <- c(climate_3k, climate_2k, climate_1k)
plot(s)
cr <- crop(s, c(-60,-50,-35,-25))
plot(cr)
cr <- crop(s, c(-60,-45,-35,-25))
plot(cr)
cr <- crop(s, c(-60,-45,-35,-20))
plot(cr)
get_biome_classes(Beyer2020)
get_biome_classes("Beyer2020")
get_biome_classes("Krapp2021")
download_dataset("Krapp2021")
get_biome_classes("Beyer2020")
climate_3k <- region_slice(
time_bp = -3000,
bio_variables = c("biome"),
dataset = "Krapp2021"
)
climate_2k <- region_slice(
time_bp = -2000,
bio_variables = c("biome"),
dataset = "Krapp2021"
)
climate_1k <- region_slice(
time_bp = -1000,
bio_variables = c("biome"),
dataset = "Krapp2021"
)
s <- c(climate_3k, climate_2k, climate_1k)
cr <- crop(s, c(-60,-45,-35,-20))
plot(cr)
library(p3k14c)
# install.packages("remotes")
remotes::install_github("people3k/p3k14c@2022.06")
library(p3k14c)
p3k14c::p3k14c_data
head(p3k14c::p3k14c_data)
names(p3k14c::p3k14c_data)
library(p3k14c)
data
p3k14c_data
write.csv(p3k14c_data, "p3k14c.csv")
library(pastclim)
download_dataset(dataset = "Krapp2021")
get_downloaded_datasets()
help("Beyer2020")
help("Krapp2021")
help("Barreto2023")
get_vars_for_dataset(dataset = "Barreto2023")
r <- raster(region_slice(-11000, bio_variables = "bio01", dataset="Barreto2023"))
r <- rast(region_slice(-11000, bio_variables = "bio01", dataset="Barreto2023"))
download_dataset(dataset = "Barreto2023")
r <- rast(region_slice(-11000, bio_variables = "bio01", dataset="Barreto2023"))
plot(r)
r <- rast(region_slice(-11000, bio_variables = "bio01", dataset="Krapp2021"))
plot(r)
# Install and load spatstat package
install.packages("spatstat")
library(spatstat)
# Load example dataset
data(cells)
# Fit a point process model (homogeneous Poisson process)
fit <- ppm(cells, ~1)
# Generate an envelope around the K-function
envel <- envelope(cells, Kest, nsim=39, rank=1)
# Plot the envelope
plot(envel)
envel$lo
Kest(cells)
obs_k <- Kest(cells)
obs_k
cells
update.packages(ask = FALSE, checkBuilt = TRUE)
library(terra)
library(terra)
f <- list.files("sel_rasters", full.names=T, pattern=".tif$")
dem <- rast("sel_rasters/cropped_dem.tif")
for (file in f) { x <- rast(file); x <- project(x, dem); writeRaster(x, paste0("proj_rasters/", names(x), ".tif")); rm(x); gc() }
f
basename(f)
for (file in f) { x <- rast(file); x <- project(x, dem); writeRaster(x, paste0("proj_rasters/", basename(file))); rm(x); gc() }
f <- list.files("proj_rasters", full.names=T)
f
r <- rast(f)
plot(r)
names(r)
unique(names(r))
plot(r[[6]])
plot(r[[21]])
names(r[[21]]) <- "twi"
plot(r[[21]])
r[[21]]
writeRaster(r[[21]], "proj_rasters/twi.tif")
f <- list.files("proj_rasters", full.names=T)
r <- rast(f)
plot(r)
names(r)
a <- read.csv("pts.csv")
a
head(a)
head(a, header=NULL)
read.csv("pts.csv", header=NULL)
a <- read.csv("pts.csv")
a
head(a)
library(sf)
pts <- st_as_sf(a)
pts <- st_as_sf(a, coords = c("x", "y"))
pts
plot(pts)
library(gstat)
vgm <- variogram(z~1, pts)
plot(vgm)
fit <- fit.variogram(vgm, vgm(6, c("Exp", "Sph", "Gau"), 50, 0))
plot(vgm, fit)
site_bound <- vect("data/shp/site_bound.shp")
library(terra)
site_bound <- vect("~/projects/caldeirao/data/shp/site_bound.shp")
# grid for interpolation
xrange <- seq(ext(site_bound)[1], ext(site_bound)[2], 1)
yrange <- seq(ext(site_bound)[3], ext(site_bound)[4], 1)
zrange <- seq(10,90,20)
site_grid <- expand.grid(xrange, yrange, zrange)
colnames(site_grid) <- c("x", "y", "z")
site_grid <- st_as_sf(site_grid, coords=c("x", "y", "z"), crs=st_crs(site_bound))
plot(site_grid)
site_bound <- vect("~/projects/caldeirao/data/shp/site_bound.shp")
# grid for interpolation
xrange <- seq(ext(site_bound)[1], ext(site_bound)[2], 1)
yrange <- seq(ext(site_bound)[3], ext(site_bound)[4], 1)
site_grid <- expand.grid(xrange, yrange)
colnames(site_grid) <- c("x", "y")
site_grid <- st_as_sf(site_grid, coords=c("x", "y"), crs=st_crs(site_bound))
plot(site_grid)
krig <- krige(z~1, pts, site_grid, fit)
st_crs(pts)
st_crs(pts) <- st_crs(site_grid)
krig <- krige(z~1, pts, site_grid, fit)
krig
plot(krig)
r <- rast(krig$var1.pred)
krig$var1.pred
r <- rast(site_grid)
r
plot(r)
values(r) <- krig$var1.pred
raster_template <- rast(ext(krig), res=1)
r <- rasterize(krig, raster_template, "var1.pred")
plot(r)
m <- mask(r, site_bound)
st_crs(r)
st_crs(r) <- st_crs(site_bound)
crs(r) <- st_crs(site_bound)
crs(r) <- crs(site_bound)
m <- mask(r, site_bound)
plot(m)
writeRaster(m, "caldeiao_topo.tif")
df <- as.data.frame(m, xy = TRUE)
names(df) <- c("x", "y", "z")
model <- lm(z ~ poly(x, 2) + poly(y, 2), data = df)
df$trend <- predict(model, newdata = df)
df$detrended <- df$z - df$trend
detrended_raster <- m
values(detrended_raster) <- df$detrended
plot(detrended_raster)
df <- as.data.frame(r, xy = TRUE)
names(df) <- c("x", "y", "z")
model <- lm(z ~ poly(x, 2) + poly(y, 2), data = df)
df$trend <- predict(model, newdata = df)
df$detrended <- df$z - df$trend
detrended_raster <- r
values(detrended_raster) <- df$detrended
plot(detrended_raster)
setwd("projects/agro-transition-final/")
required_packages <- c(
"ape", "caret", "dplyr", "fastshap", "fields", "ggplot2", "gridExtra",
"latticeExtra", "progress", "randomForestSRC", "rasterVis", "RColorBrewer",
"rnaturalearth", "rnaturalearthdata", "sf", "sp", "shapviz", "terra",
"tidyterra", "vegan", "ggpubr", "ade4"
)
missing_packages <- required_packages[!(required_packages %in% installed.packages()[,"Package"])]
if(length(missing_packages)) {
print("Installing dependencies...")
install.packages(missing_packages)
}
library(ape)
library(caret)
library(dplyr)
library(fastshap)
library(fields)
library(ggplot2)
library(gridExtra)
library(latticeExtra)
library(progress)
library(randomForestSRC)
library(rasterVis)
library(RColorBrewer)
library(rnaturalearth)
library(rnaturalearthdata)
library(sf)
library(sp)
library(shapviz)
library(terra)
library(tidyterra)
library(vegan)
library(ggpubr)
library(ade4)  # Dependency for quickMEM
sf_use_s2(FALSE)
# please download the quickMEM source code from
# https://github.com/ajsmit/Quantitative_Ecology/blob/main/Num_Ecol_R_book_ed1/quickMEM.R
source("quickMEM.R")
source("var_names.R")
# ---------------------------------------------------------
# Data preparation
# Define datum
WGS84 <- '+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs'
# Mask the NA cells for plotting
bio <- rast("rasters/bioclim/bio01.asc")
alt <- rast("rasters/terrain/altitude.asc")
land_mask <- (!is.na(bio) & !is.na(alt))
# For the figures
coast <- st_union(ne_countries())
# Read data
raw_data <- read.csv("data/c14dates.csv")
all_data_points <- st_as_sf(raw_data, coords=c("Longitude", "Latitude"), crs=WGS84)
all_data_points <- all_data_points[order(all_data_points$AgeCalBP), ]
# Ages
age_plot <- ggplot() +
geom_sf(data=coast, fill="white") +
geom_sf(data=all_data_points, aes(col=AgeCalBP), size=0.5, alpha=0.5) +
scale_color_viridis_c(option="turbo", name="Age (cal BP)") +
scale_x_continuous(expand = c(0,0)) +
scale_y_continuous(expand = c(0,0)) +
coord_sf(ylim = c(-60, 90))
jpeg("figs/C14Ages.jpg", width=2000, height=1000, res=300)
plot(age_plot)
dev.off()
# Sources
all_data_points$Database[all_data_points$Database == ""] <- "Other source"
n <- length(unique(all_data_points$Database))
source_plot <- ggplot() +
geom_sf(data=coast, fill="white") +
geom_sf(data=all_data_points, aes(col=Database), size=0.5, alpha=0.5) +
scale_color_manual(values = colorRampPalette(brewer.pal(8, "Set3"))(n)) +
scale_x_continuous(expand = c(0,0)) +
scale_y_continuous(expand = c(0,0)) +
coord_sf(ylim = c(-60, 90))
jpeg("figs/C14Sources.jpg", width=2000, height=1000, res=300)
plot(source_plot)
dev.off()
# Read all environmental rasters
# we read them separately for varpart
bioclim_files <- list.files("rasters/bioclim", full.names=T)
soil_files <- list.files("rasters/edaphic", full.names=T)
terrain_files <- list.files("rasters/terrain", full.names=T)
layers <- c(rast(bioclim_files), rast(soil_files), rast(terrain_files))
# Fill NAs within a radius of 3 cells to avoid loosing data
# especially on coastal regions.
layers <- focal(layers, w=matrix(1,3,3), fun=mean, na.policy="only")
# Create layers with latitude and longitude to be added as predictors
rlon <- rlat <- rast(layers[[1]])
xy <- xyFromCell(layers[[1]], 1:ncell(layers[[1]]))
values(rlon) <- xy[,1]
values(rlat) <- xy[,2]
names(rlon) <- "xcoord"
names(rlat) <- "ycoord"
layers <- c(layers, rlon, rlat)
# Extract environmental data for each point and create a data frame
data <- terra::extract(layers, raw_data[c("Longitude", "Latitude")], ID=FALSE)
# Target variable is time since first transition
data$y <- max(raw_data$AgeCalBP) - raw_data$AgeCalBP
data <- na.omit(data)
# Store latitude and longitude for use later
xcoord <- data$xcoord
ycoord <- data$ycoord
# Predictors and target
X <- data[,1:(ncol(data)-3)]
y <- data$y
# Remove collinearity
cor_vars <- findCorrelation(cor(X), names=T)
X <- X[,!colnames(X) %in% cor_vars]
findLinearCombos(X) # none
layers <- subset(layers, cor_vars, negate=T)
data <- data[,!colnames(data) %in% cor_vars]
data2 <- read.csv("saved_data/data.csv")
head(data)
head(data2)
library(colorblindcheck)
install.packages("colorblindcheck")
library(colorblindcheck)
x <- viridisMap(option="turbo")
x
palette_check(x)
get_gradient <- function(n, colors = c("blue", "red")) {
colorRampPalette(colors)(n)
}
# Example: Generate a gradient with 10 colors
hex_colors <- get_gradient(10)
print(hex_colors)
palette_check(hex_colors)
palette_check(hex_colors, plot=T)
get_gradient <- function(n, colors = c("#0089fb", "#ff004e")) {
colorRampPalette(colors)(n)
}
# Example: Generate a gradient with 10 colors
hex_colors <- get_gradient(10)
print(hex_colors)
palette_check(hex_colors, plot=T)
load("saved_data/explainer.RData")
shv <- shapviz(explainer, X=xvars)
xvars <- select(data, -c(y, event))
# For random forest
data$event <- 1
xvars <- select(data, -c(y, event))
jpeg("figs/ShapSummary.jpg", width=2000, height=1000, res=300)
sv_importance(shv, max_display=10, kind="beeswarm", size=0.5, alpha=0.5) +
scale_color_gradient(low="#0089fb", high="#ff004e")
shv <- shapviz(explainer, X=xvars)
colnames(xvars) <- var_names[colnames(xvars)]
shv <- shapviz(explainer, X=xvars)
jpeg("figs/ShapSummary.jpg", width=2000, height=1000, res=300)
sv_importance(shv, max_display=10, kind="beeswarm", size=0.5, alpha=0.5) +
scale_color_gradient(low="#0089fb", high="#ff004e")
dev.off()
jpeg("figs/ShapSummary.jpg", width=2000, height=1000, res=300)
sv_importance(shv, max_display=10, kind="beeswarm", size=0.5, alpha=0.5) +
scale_color_gradient(low="blue", high="red")
dev.off()
jpeg("figs/ShapSummary.jpg", width=2000, height=1000, res=300)
sv_importance(shv, max_display=10, kind="beeswarm", size=0.5, alpha=0.4) +
scale_color_gradient(low="#0089fb", high="#ff004e")
dev.off()
jpeg("figs/ShapSummary.jpg", width=2000, height=1000, res=300)
sv_importance(shv, max_display=10, kind="beeswarm", size=0.5, alpha=0.6) +
scale_color_gradient(low="#0089fb", high="#ff004e")
dev.off()
jpeg("figs/ShapSummary.jpg", width=2000, height=1000, res=300)
sv_importance(shv, max_display=10, kind="beeswarm", size=0.5, alpha=0.4) +
scale_color_gradient(low="blue", high="red")
dev.off()
jpeg("figs/ShapSummary.jpg", width=2000, height=1000, res=300)
sv_importance(shv, max_display=10, kind="beeswarm", size=0.5, alpha=0.5) +
scale_color_gradient(low="blue", high="red")
dev.off()
sv_importance(shv, max_display=10, kind="beeswarm", size=0.5, alpha=0.5) +
scale_color_gradient(low="#0086fa", high="#ff004d")
# Spatial distribution of Shapley values
shap_maps <- lapply(1:4, function(i) {
shap_points_ordered <- shap_points %>% arrange(get(top_vars[i]))
ggplot() +
geom_sf(data=coast, fill="white") +
geom_sf(data=shap_points_ordered, aes(color=get(top_vars[i])), size=0.2, alpha=0.5) +
scale_color_viridis_c(option="turbo", name="Shapley value") +
scale_x_continuous(expand = c(0,0)) +
scale_y_continuous(expand = c(0,0)) +
coord_sf(ylim = c(-60, 90)) +
labs(title=top_vars[i]) +
theme(
plot.title = element_text(
size = 10,
hjust = 0.5
),
legend.title = element_text(size=8)
)
})
top_vars <- names(sort(apply(abs(explainer), 2, mean), decreasing=T))
top_vars <- top_vars[top_vars != "Longitude" & top_vars != "Latitude"]
shap_scores_df <- as.data.frame(explainer)
shap_scores_df$xcoord <- data$xcoord
shap_scores_df$ycoord <- data$ycoord
shap_points <- st_as_sf(shap_scores_df, coords=c("xcoord", "ycoord"), crs=WGS84)
ggarrange(plotlist=dependence_plots, common.legend=TRUE, legend="right")
dependence_plots <- lapply(1:4, function(i) {
sv_dependence(shv, v=top_vars[i], size=0.6, alpha=0.5) +
scale_color_gradient(low="#0086fa", high="#ff004d") +
# change y labels to "Shapley value"
labs(y="Shapley value")
})
ggarrange(plotlist=dependence_plots, common.legend=TRUE, legend="right")
