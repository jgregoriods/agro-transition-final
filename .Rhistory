best_score <- least_squares(m$d18O, foo(m$erj_dist, A, x0, X, M))
best_params <- c(A, x0, X, M)
cat("Initial best score: ", best_score, "\n")
for (i in 1:nrow(grid)) {
score <- least_squares(m$d18O, foo(m$erj_dist, grid[i,]$A, grid[i,]$x0, grid[i,]$X, grid[i,]$M))
if (score < best_score) {
best_score <- score
best_params <- c(grid[i,]$A, grid[i,]$x0, grid[i,]$X, grid[i,]$M)
cat("New best score: ", best_score, "\n")
}
}
gc()
rm(grid)
gc()
grid <- expand.grid(A = seq(0.8, 1.2, 0.02), x0 = seq(0, 5, 0.02), X = seq(19, 26, 0.2), M = seq(-8, -4, 0.2))
best_score <- least_squares(m$d18O, foo(m$erj_dist, A, x0, X, M))
best_params <- c(A, x0, X, M)
pb <- txtProgressBar(min = 0, max = nrow(grid), style = 3)
cat("Initial best score: ", best_score, "\n")
for (i in 1:nrow(grid)) {
score <- least_squares(m$d18O, foo(m$erj_dist, grid[i,]$A, grid[i,]$x0, grid[i,]$X, grid[i,]$M))
if (score < best_score) {
best_score <- score
best_params <- c(grid[i,]$A, grid[i,]$x0, grid[i,]$X, grid[i,]$M)
cat("New best score: ", best_score, "\n")
}
setTxtProgressBar(pb, i)
}
close(pb)
gc()
rm(grid)
gc()
best_params
plot(m)
yhat <- foo(m$erj_dist, best_params[1], best_params[2], best_params[3], best_params[4])
lines(m$erj_dist, yhat)
grid <- expand.grid(A = seq(0.9, 1.1, 0.02), x0 = seq(1, 4, 0.02), X = seq(20, 26, 0.2), M = seq(-7, -3, 0.2))
best_score <- least_squares(m$d18O, foo(m$erj_dist, A, x0, X, M))
best_params <- c(A, x0, X, M)
pb <- txtProgressBar(min = 0, max = nrow(grid), style = 3)
cat("Initial best score: ", best_score, "\n")
for (i in 1:nrow(grid)) {
score <- least_squares(m$d18O, foo(m$erj_dist, grid[i,]$A, grid[i,]$x0, grid[i,]$X, grid[i,]$M))
if (score < best_score) {
best_score <- score
best_params <- c(grid[i,]$A, grid[i,]$x0, grid[i,]$X, grid[i,]$M)
cat("New best score: ", best_score, "\n")
}
setTxtProgressBar(pb, i)
}
rm(grid)
gc()
library(randomsearch)
install.packages("randomsearch")
install.packages('randomsearch')
devtools::install_github("jakob-r/randomsearch")
library(randomsearch)
obj.fun <- makeSingleObjectiveFunction(
fn = function(x) {
return (least_squares(m$d18O, foo(m$erj_dist, x[1], x[2], x[3], x[4])))
},
par.set = makeParamSet(
makeNumericParam("A", lower = 0.9, upper = 1.1),
makeNumericParam("x0", lower = 1, upper = 4),
makeNumericParam("X", lower = 20, upper = 26),
makeNumericParam("M", lower = -7, upper = -3)
)
)
obj.fun
r <- randomsearch(obj.fun)
r
summary(r)
obj.fun <- makeSingleObjectiveFunction(
fn = function(x) {
return (least_squares(m$d18O, foo(m$erj_dist, x[1], x[2], x[3], x[4])) * -1)
},
par.set = makeParamSet(
makeNumericParam("A", lower = 0.9, upper = 1.1),
makeNumericParam("x0", lower = 1, upper = 4),
makeNumericParam("X", lower = 20, upper = 26),
makeNumericParam("M", lower = -7, upper = -3)
)
)
r <- randomsearch(obj.fun)
r
obj.fun <- makeSingleObjectiveFunction(
fn = function(x) {
return (least_squares(m$d18O, foo(m$erj_dist, x[1], x[2], x[3], x[4])))
},
par.set = makeParamSet(
makeNumericParam("A", lower = 0.9, upper = 1.1),
makeNumericParam("x0", lower = 1, upper = 4),
makeNumericParam("X", lower = 20, upper = 26),
makeNumericParam("M", lower = -7, upper = -3)
)
)
r <- randomsearch(obj.fun)
r
r <- randomsearch(obj.fun, max.evals = 100)
r
r <- randomsearch(obj.fun, max.evals = 1000)
r
res <- randomSearch(obj.fun, max.eval = 1000)
res <- randomsearch(obj.fun, max.eval = 1000)
yhat <- foo(m$erj_dist, res$xbest[1], res$xbest[2], res$xbest[3], res$xbest[4])
yhat
res$par.set
res
res$minimize
res$add.transformed.x
res$env
summary(res)
summary(res)$x
str(res)
summary(res)[1]
summary(res)[2]
summary(res)$best.x
summary(res)$best.x$A
yhat <- foo(m$erj_dist, summary(res)$best.x$A, summary(res)$best.x$x0, summary(res)$best.x$X, summary(res)$best.x$M)
yhat
plot(m$erj_dist, m$d18O)
lines(m$erj_dist, yhat)
res <- randomsearch(obj.fun, max.eval = 10000)
res
yhat <- foo(m$erj_dist, summary(res)$best.x$A, summary(res)$best.x$x0, summary(res)$best.x$X, summary(res)$best.x$M)
plot(m$erj_dist, m$d18O)
lines(m$erj_dist, yhat)
optim
optim()
least_squares <- function(y, y_hat) {
return (sum((y - y_hat)^2))
}
fn <- function(x) {
A <- x[1]
x0 <- x[2]
X <- x[3]
M <- x[4]
return (least_squares(m$d18O, foo(m$erj_dist, A, x0, X, M)))
}
m <- read.csv("mod.csv")
A <- (max(m$d18O) - min(m$d18O))/2
x0 <- m[which.max(m$d18O),]$erj_dist
M <- (max(m$d18O) + min(m$d18O))/2
X <- max(m$erj_dist) - min(m$erj_dist)
A
res <- optim(c(A, x0, X, M), fn)
foo <- function(x, A, x0, X, M) {
return ((A * cos(2*pi*((x-x0)/X))) + M)
}
res <- optim(c(A, x0, X, M), fn)
res
res <- optim(c(A, x0, X, M), fn, method="BFGS")
res
res <- optim(c(A, x0, X, M), fn, method="CG")
res
res <- optim(c(A, x0, X, M), fn, method="L-BFGS-B")
res
res <- optim(c(A, x0, X, M), fn, method="SANN")
res
res <- optim(c(A, x0, X, M), fn, method="Brent")
source("mod.R")
res
res <- optim(res$par, fn)
res
M
m
m <- m[(nrow(m)-1),]
m
m <- read.csv("mod.csv")
m <- m[1:(nrow(m)-1),]
m
A <- (max(m$d18O) - min(m$d18O))/2
x0 <- m[which.max(m$d18O),]$erj_dist
M <- (max(m$d18O) + min(m$d18O))/2
X <- max(m$erj_dist) - min(m$erj_dist)
res <- optim(c(A, x0, X, M), fn)
res
source("mod.R")
res
library(pastclim)
climate_20k <- region_slice(
time_bp = -20000,
bio_variables = c("bio01", "bio10", "bio12"),
dataset = "Example"
)
plot(climate_20k)
climate_3k <- region_slice(
time_bp = -3000,
bio_variables = c("biome"),
dataset = "Example"
)
climate_3k <- region_slice(
time_bp = -3000,
bio_variables = c("biomes"),
dataset = "Beyer2020"
)
climate_3k <- region_slice(
time_bp = -3000,
bio_variables = c("biome"),
dataset = "Beyer2020"
)
plot(climate_3k)
climate_2k <- region_slice(
time_bp = -2000,
bio_variables = c("biome"),
dataset = "Beyer2020"
)
climate_1k <- region_slice(
time_bp = -1000,
bio_variables = c("biome"),
dataset = "Beyer2020"
)
s <- stack(climate_3k, climate_2k, climate_1k)
s <- c(climate_3k, climate_2k, climate_1k)
plot(s)
cr <- crop(s, c(-60,-50,-35,-25))
plot(cr)
cr <- crop(s, c(-60,-45,-35,-25))
plot(cr)
cr <- crop(s, c(-60,-45,-35,-20))
plot(cr)
get_biome_classes(Beyer2020)
get_biome_classes("Beyer2020")
get_biome_classes("Krapp2021")
download_dataset("Krapp2021")
get_biome_classes("Beyer2020")
climate_3k <- region_slice(
time_bp = -3000,
bio_variables = c("biome"),
dataset = "Krapp2021"
)
climate_2k <- region_slice(
time_bp = -2000,
bio_variables = c("biome"),
dataset = "Krapp2021"
)
climate_1k <- region_slice(
time_bp = -1000,
bio_variables = c("biome"),
dataset = "Krapp2021"
)
s <- c(climate_3k, climate_2k, climate_1k)
cr <- crop(s, c(-60,-45,-35,-20))
plot(cr)
library(p3k14c)
# install.packages("remotes")
remotes::install_github("people3k/p3k14c@2022.06")
library(p3k14c)
p3k14c::p3k14c_data
head(p3k14c::p3k14c_data)
names(p3k14c::p3k14c_data)
library(p3k14c)
data
p3k14c_data
write.csv(p3k14c_data, "p3k14c.csv")
library(pastclim)
download_dataset(dataset = "Krapp2021")
get_downloaded_datasets()
help("Beyer2020")
help("Krapp2021")
help("Barreto2023")
get_vars_for_dataset(dataset = "Barreto2023")
r <- raster(region_slice(-11000, bio_variables = "bio01", dataset="Barreto2023"))
r <- rast(region_slice(-11000, bio_variables = "bio01", dataset="Barreto2023"))
download_dataset(dataset = "Barreto2023")
r <- rast(region_slice(-11000, bio_variables = "bio01", dataset="Barreto2023"))
plot(r)
r <- rast(region_slice(-11000, bio_variables = "bio01", dataset="Krapp2021"))
plot(r)
# Install and load spatstat package
install.packages("spatstat")
library(spatstat)
# Load example dataset
data(cells)
# Fit a point process model (homogeneous Poisson process)
fit <- ppm(cells, ~1)
# Generate an envelope around the K-function
envel <- envelope(cells, Kest, nsim=39, rank=1)
# Plot the envelope
plot(envel)
envel$lo
Kest(cells)
obs_k <- Kest(cells)
obs_k
cells
update.packages(ask = FALSE, checkBuilt = TRUE)
library(terra)
library(terra)
f <- list.files("sel_rasters", full.names=T, pattern=".tif$")
dem <- rast("sel_rasters/cropped_dem.tif")
for (file in f) { x <- rast(file); x <- project(x, dem); writeRaster(x, paste0("proj_rasters/", names(x), ".tif")); rm(x); gc() }
f
basename(f)
for (file in f) { x <- rast(file); x <- project(x, dem); writeRaster(x, paste0("proj_rasters/", basename(file))); rm(x); gc() }
f <- list.files("proj_rasters", full.names=T)
f
r <- rast(f)
plot(r)
names(r)
unique(names(r))
plot(r[[6]])
plot(r[[21]])
names(r[[21]]) <- "twi"
plot(r[[21]])
r[[21]]
writeRaster(r[[21]], "proj_rasters/twi.tif")
f <- list.files("proj_rasters", full.names=T)
r <- rast(f)
plot(r)
names(r)
a <- read.csv("pts.csv")
a
head(a)
head(a, header=NULL)
read.csv("pts.csv", header=NULL)
a <- read.csv("pts.csv")
a
head(a)
library(sf)
pts <- st_as_sf(a)
pts <- st_as_sf(a, coords = c("x", "y"))
pts
plot(pts)
library(gstat)
vgm <- variogram(z~1, pts)
plot(vgm)
fit <- fit.variogram(vgm, vgm(6, c("Exp", "Sph", "Gau"), 50, 0))
plot(vgm, fit)
site_bound <- vect("data/shp/site_bound.shp")
library(terra)
site_bound <- vect("~/projects/caldeirao/data/shp/site_bound.shp")
# grid for interpolation
xrange <- seq(ext(site_bound)[1], ext(site_bound)[2], 1)
yrange <- seq(ext(site_bound)[3], ext(site_bound)[4], 1)
zrange <- seq(10,90,20)
site_grid <- expand.grid(xrange, yrange, zrange)
colnames(site_grid) <- c("x", "y", "z")
site_grid <- st_as_sf(site_grid, coords=c("x", "y", "z"), crs=st_crs(site_bound))
plot(site_grid)
site_bound <- vect("~/projects/caldeirao/data/shp/site_bound.shp")
# grid for interpolation
xrange <- seq(ext(site_bound)[1], ext(site_bound)[2], 1)
yrange <- seq(ext(site_bound)[3], ext(site_bound)[4], 1)
site_grid <- expand.grid(xrange, yrange)
colnames(site_grid) <- c("x", "y")
site_grid <- st_as_sf(site_grid, coords=c("x", "y"), crs=st_crs(site_bound))
plot(site_grid)
krig <- krige(z~1, pts, site_grid, fit)
st_crs(pts)
st_crs(pts) <- st_crs(site_grid)
krig <- krige(z~1, pts, site_grid, fit)
krig
plot(krig)
r <- rast(krig$var1.pred)
krig$var1.pred
r <- rast(site_grid)
r
plot(r)
values(r) <- krig$var1.pred
raster_template <- rast(ext(krig), res=1)
r <- rasterize(krig, raster_template, "var1.pred")
plot(r)
m <- mask(r, site_bound)
st_crs(r)
st_crs(r) <- st_crs(site_bound)
crs(r) <- st_crs(site_bound)
crs(r) <- crs(site_bound)
m <- mask(r, site_bound)
plot(m)
writeRaster(m, "caldeiao_topo.tif")
df <- as.data.frame(m, xy = TRUE)
names(df) <- c("x", "y", "z")
model <- lm(z ~ poly(x, 2) + poly(y, 2), data = df)
df$trend <- predict(model, newdata = df)
df$detrended <- df$z - df$trend
detrended_raster <- m
values(detrended_raster) <- df$detrended
plot(detrended_raster)
df <- as.data.frame(r, xy = TRUE)
names(df) <- c("x", "y", "z")
model <- lm(z ~ poly(x, 2) + poly(y, 2), data = df)
df$trend <- predict(model, newdata = df)
df$detrended <- df$z - df$trend
detrended_raster <- r
values(detrended_raster) <- df$detrended
plot(detrended_raster)
library(gstat)
library(sf)
library(terra)
library(ggplot2)
library(ggrepel)
library(ggspatial)
library(tidyterra)
sessionInfo()
packageVersion("gstat")
packageVersion("sf")
packageVersion("terra")
packageVersion("ggplot2")
packageVersion("ggrepel")
packageVersion("ggspatial")
packageVersion("tidyterra")
setwd("projects/agro-transition-final/")
required_packages <- c(
"ape", "caret", "dplyr", "fastshap", "fields", "ggplot2", "gridExtra",
"latticeExtra", "progress", "randomForestSRC", "rasterVis", "RColorBrewer",
"rnaturalearth", "rnaturalearthdata", "sf", "sp", "shapviz", "terra",
"tidyterra", "vegan", "ggpubr", "ade4"
)
missing_packages <- required_packages[!(required_packages %in% installed.packages()[,"Package"])]
if(length(missing_packages)) {
print("Installing dependencies...")
install.packages(missing_packages)
}
library(ape)
library(caret)
library(dplyr)
library(fastshap)
library(fields)
library(ggplot2)
library(gridExtra)
library(latticeExtra)
library(progress)
library(randomForestSRC)
library(rasterVis)
library(RColorBrewer)
library(rnaturalearth)
library(rnaturalearthdata)
library(sf)
library(sp)
library(shapviz)
library(terra)
library(tidyterra)
library(vegan)
library(ggpubr)
library(ade4)  # Dependency for quickMEM
sf_use_s2(FALSE)
# please download the quickMEM source code from
# https://github.com/ajsmit/Quantitative_Ecology/blob/main/Num_Ecol_R_book_ed1/quickMEM.R
source("quickMEM.R")
source("var_names.R")
# ---------------------------------------------------------
# Data preparation
# Define datum
WGS84 <- '+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs'
# Mask the NA cells for plotting
bio <- rast("rasters/bioclim/bio01.asc")
alt <- rast("rasters/terrain/altitude.asc")
land_mask <- (!is.na(bio) & !is.na(alt))
# For the figures
coast <- st_union(ne_countries())
# Read data
raw_data <- read.csv("data/c14dates.csv")
all_data_points <- st_as_sf(raw_data, coords=c("Longitude", "Latitude"), crs=WGS84)
all_data_points <- all_data_points[order(all_data_points$AgeCalBP), ]
data <- read.csv("saved_data/data.csv")
# For random forest
data$event <- 1
load("saved_data/rf_model.RData")
rf_stack <- rast("saved_data/rf_stack.tif")
predicted_time_r <- rast("saved_data/predicted_time_r.tif")
xvars <- select(data, -c(y, event))
colnames(xvars) <- var_names[colnames(xvars)]
load("saved_data/explainer.RData")
shv <- shapviz(explainer, X=xvars)
sv_importance(shv, max_display=10, kind="beeswarm", size=0.5, alpha=0.5) +
scale_color_gradient(low="#0086fa", high="#ff004d")
top_vars <- names(sort(apply(abs(explainer), 2, mean), decreasing=T))
top_vars <- top_vars[top_vars != "Longitude" & top_vars != "Latitude"]
shap_scores_df <- as.data.frame(explainer)
shap_scores_df$xcoord <- data$xcoord
shap_scores_df$ycoord <- data$ycoord
shap_points <- st_as_sf(shap_scores_df, coords=c("xcoord", "ycoord"), crs=WGS84)
# Spatial distribution of Shapley values
shap_maps <- lapply(1:8, function(i) {
shap_points_ordered <- shap_points %>% arrange(get(top_vars[i]))
ggplot() +
geom_sf(data=coast, fill="white") +
geom_sf(data=shap_points_ordered, aes(color=get(top_vars[i])), size=0.2, alpha=0.5) +
scale_color_viridis_c(option="turbo", name="Shapley value") +
scale_x_continuous(expand = c(0,0)) +
scale_y_continuous(expand = c(0,0)) +
coord_sf(ylim = c(-60, 90)) +
labs(title=top_vars[i]) +
theme(
plot.title = element_text(
size = 10,
hjust = 0.5
),
legend.title = element_text(size=8)
)
})
ggarrange(plotlist=shap_maps, common.legend=TRUE, legend="right")
# Spatial distribution of Shapley values
shap_maps <- lapply(1:12, function(i) {
shap_points_ordered <- shap_points %>% arrange(get(top_vars[i]))
ggplot() +
geom_sf(data=coast, fill="white") +
geom_sf(data=shap_points_ordered, aes(color=get(top_vars[i])), size=0.2, alpha=0.5) +
scale_color_viridis_c(option="turbo", name="Shapley value") +
scale_x_continuous(expand = c(0,0)) +
scale_y_continuous(expand = c(0,0)) +
coord_sf(ylim = c(-60, 90)) +
labs(title=top_vars[i]) +
theme(
plot.title = element_text(
size = 10,
hjust = 0.5
),
legend.title = element_text(size=8)
)
})
ggarrange(plotlist=shap_maps, common.legend=TRUE, legend="right")
